use crate::board::{Board, Color, PieceType};

pub fn evaluate_position(board: &Board) -> i32 {
    let mut score = 0;

    // Material values
    let material_values = [
        (PieceType::Pawn, 100),
        (PieceType::Knight, 320),
        (PieceType::Bishop, 330),
        (PieceType::Rook, 500),
        (PieceType::Queen, 900),
        (PieceType::King, 20000),
    ];

    for (piece_type, value) in &material_values {
        for color in [Color::White, Color::Black] {
            let pieces = board.get_pieces(*piece_type, color);
            let piece_count = pieces.count_ones();
            let material_score = piece_count as i32 * value;

            if color == Color::White {
                score += material_score;
            } else {
                score -= material_score;
            }
        }
    }

    // Simple positional bonuses
    score += evaluate_piece_positions(board);

    // Adjust score based on side to move
    if board.side_to_move() == Color::White {
        score += 10;
    } else {
        score -= 10;
    }

    score
}

fn evaluate_piece_positions(board: &Board) -> i32 {
    let mut score = 0;

    // Center control bonus
    let _center_squares = [
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h1
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h2
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h3
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h4
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h5
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h6
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h7
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // a8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // b8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // c8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // d8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // e8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // f8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // g8
        0b0000_0000_0000_0000_0000_0000_0000_0000u64, // h8
    ];

    // Center squares (d4, e4, d5, e5)
    let center_mask = 0b0000_0000_0000_0000_0000_0000_0011_0000u64 |
                      0b0000_0000_0000_0000_0000_0000_1100_0000u64;

    for color in [Color::White, Color::Black] {
        for piece_type in [PieceType::Pawn, PieceType::Knight, PieceType::Bishop] {
            let pieces = board.get_pieces(piece_type, color);
            let center_control = (pieces & center_mask).count_ones();
            let bonus = center_control as i32 * 20;
            
            if color == Color::White {
                score += bonus;
            } else {
                score -= bonus;
            }
        }
    }

    score
}
